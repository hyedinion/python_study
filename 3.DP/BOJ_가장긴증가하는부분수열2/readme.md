# [BOJ]/[12015] 가장 긴 증가하는 부분 수열 2

## 분류
DP, 이분탐색(lower_bound)

## 접근법
- 이 풀이법은 전체"길이"를 계산할 때만 사용한다.
- 만약 "부분수열" 자체를 return해야한다면 이 알고리즘은 정답이 될 수 없다.

1. input num을 확인하면서 만약 가장큰값이면 answer에 append한다.
2. 만약 가장큰값이 아니면 나보다 크거나 같은 값중 가장 작은 값을 update 해준다.
    - 만약 num이 현재 부분수열[i] "A" 가 나보다 크거나 같고 부분수열[i-1] "B" 가 나보다 작다면 부분수열[i]를 num으로 update 해주어야된다.
    - 부분수열을 가장 작은 값들로 이루도록 유지해 주는것이다. (정답수열은 아니지만 전체 길이에는 영향을 주지 않음)
    - 그래야 새로운 가장긴 증가하는 부분수열이 나타났을 때 update할 수 있기 때문
    - 아래 예시를 참고할 때 만약 input이 6번까지 있었다면 {4 5 6 1 2 7} answer배열은 1267이지만 정답수열은 4567이고 길이는 영향이 없다. 이것은 예전의 456이 있었다고 길이만 기억하고 7을 append하는것과 같이 생각할 수 있다.
    - 하지만 아래 예시처럼 input이 주어진다면 만약 가장 작은값들로 부분수열을 유지해주지 않으면 5를 append할 수 없을 것이다.
    - 이 때sms 4567에 append한다고 생각하는 것이 아니라 1234에 append한다고 생각해주면 된다.
3. len(answer)을 return한다.

### 예시
수열 A = {4 5 6 1 2 7 3 4 5}
1. 4
2. 45
3. 456
4. 156 -> 실제로 정답 수열은 456이지만 전체길이는 변함이 없다. 중간 DP값은 찾을 수 있다. DP[1] = 1으로 저장할 수 있다.
5. 126 -> 정답수열 : 456 , 길이 : 3
6. 1267 -> 정답수열 : 4567, 길이 : 4
7. 1237 -> 정답수열 : 4567, 길이 : 4
8. 1234 -> 정답수열 : 1234,4567 길이 : 4
9. 12345 -> 정답수열 : 12345 길이 : 5

## 이분탐색
```python
def find_index(i):
    start = 0
    end = len(answer)
    index = 0
    while start<=end:
        mid = (start+end)//2
        if answer[mid]>=i:
            end = mid-1
            index = mid
        else:
            start = mid+1
    return index
```
1. 크거나 같은수 중 가장 작은값 찾기
    - if answer[mid]>=num : end = mid-1; answer = mid
2. 작거나 같은수 중 가장 큰값 찾기
    - if answer[mid]<=num : start = mid+1; answer = mid

## 놓친것
1. i,j 구분 잘하기
2. DP[current]와 DP[pre]+1 중 큰값을 해야한다. 둘다 +1하면 안됨

## 후기
가장긴감소하는부분수열 풀어서 DP로 쉽게 풀었는데 시간초과..<br>
이분탐색도 섞어야 되는 문제...<br>
하.. 산넘어산<br>
이분탐색도 공부하기~<br>